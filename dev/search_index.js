var documenterSearchIndex = {"docs":
[{"location":"api/#EarthEngine.jl-API","page":"API","title":"EarthEngine.jl API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The EarthEngine.jl API dynamically wraps the EarthEngine Python API, so it defines the types and methods on-the-fly when initializing a session. This means there are few actual Julia functions defined mostly meant to create Julia methods and types from the Python API (see below).","category":"page"},{"location":"api/","page":"API","title":"API","text":"For more in depth documentation on specific methods for using the EarthEngine API, see the official Earth Engine Documention.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Initialize()","category":"page"},{"location":"api/#EarthEngine.Initialize-Tuple{}","page":"API","title":"EarthEngine.Initialize","text":"Initialize(args...; kwargs...)\n\nFunction to initialize an EarthEngine session (analagous to ee.Initialize() from the Python API). Accepts arguments and keywords from the Python ee.Initialize() function. This function also dynamically builds the EE API and creates the methods with signatures for each EE Type.\n\n\n\n\n\n","category":"method"},{"location":"api/","page":"API","title":"API","text":"@eefunc","category":"page"},{"location":"api/#EarthEngine.@eefunc","page":"API","title":"EarthEngine.@eefunc","text":"@eefunc method\n\nMacro to wrap Julia defined method on the Python side. This is needed when applying functions to specific types such as EE.List.\n\n\n\n\n\n@eefunc method type\n\nMacro to wrap Julia defined method with a specific type signature on the Python side. This is needed when applying functions with type annotations using map()\n\n\n\n\n\n","category":"macro"},{"location":"api/","page":"API","title":"API","text":"EarthEngine.eefunc","category":"page"},{"location":"api/#EarthEngine.eefunc","page":"API","title":"EarthEngine.eefunc","text":"eefunc(method)\n\nFunction to wrap Julia defined method on the Python side. This is needed when applying functions to specific types such as EE.List.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"EarthEngine.ee_wrap","category":"page"},{"location":"api/#EarthEngine.ee_wrap","page":"API","title":"EarthEngine.ee_wrap","text":"ee_wrap(pyo::PyObject)\n\nFunction for wrapping a Python object defined in the type map\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"EarthEngine.pyattr","category":"page"},{"location":"api/#EarthEngine.pyattr","page":"API","title":"EarthEngine.pyattr","text":"pyattr(class method orig_method)\n\nFunction for creating a method signature for a Julia Type In Python world method(T::class) is analagous to class.method()\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"EarthEngine.@pytype","category":"page"},{"location":"api/#EarthEngine.@pytype","page":"API","title":"EarthEngine.@pytype","text":"@pytype name class\n\nMacro for creating a Julia Type that wraps a PyObject class\n\n\n\n\n\n","category":"macro"},{"location":"api/","page":"API","title":"API","text":"EarthEngine.pyattr_set","category":"page"},{"location":"api/#EarthEngine.pyattr_set","page":"API","title":"EarthEngine.pyattr_set","text":"pyattr_set(types, methods...)\n\nFor each Julia type T<:AbstractEEObject in types and each method m in methods, define a new function m(t::T, args...) that delegates to the underlying pyobject wrapped by t.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"EarthEngine.@pyattr","category":"page"},{"location":"api/#EarthEngine.@pyattr","page":"API","title":"EarthEngine.@pyattr","text":"@pyattr class method\n\nMacro for creating a method signature for a Julia Type In Python world method(T::class) is analagous to class.method()\n\n\n\n\n\n@pyattr class method orig_method\n\nMacro for creating a method signature for a Julia Type In Python world method(T::class) is analagous to class.method() This will create a new method name which calls the orig_method\n\n\n\n\n\n","category":"macro"},{"location":"usage/#EarthEngine.jl-Usage","page":"Usage","title":"EarthEngine.jl Usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"This document serves to illustrate and discuss some of the internals and interesting bits when using the EarthEngine.jl Julia API.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The Julia API imports the majority of the functions from the Python API (if there is anything missing please log an issue). The functions lose the ee.Type syntax so the one can simply call the methods by name and not have as much code. For example ee.Reducer.histogram() is simply histogram() in the Julia API. There are multiple versions of some methods depending on the ee.Type (like mean()) the differences get handled by Julia's multiple dispatch, see Leveraging Julia's multiple distpatch section for details.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Another notable difference is how methods are called. For example, if you would like to filter an ImageCollection and then reduce an Image, the syntax changes from imagecollection.filterDate(start,end).mean() to mean(filterDate(imagecollection, start, end)). This makes the syntax more like native Julia syntax and not object oriented. If you like the Python API of interfacing with EE or want to easily convert your Python code to Julia, then see the Using the Python API through Julia section.","category":"page"},{"location":"usage/#Importing-the-package","page":"Usage","title":"Importing the package","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The official name of this package is EarthEngine, this naming convention is used for importing the package to Julia (i.e. using EarthEngine). When getting started, users have to run the function Initialize() to start an Earth Engine session (this is the same in the Python API). Initialize() also dynamically builds the Julia API from the Python API, therefore is can take a few seconds to load. If Initialize() is not run before tying any workflow with EarthEngine, you will get an error: ERROR: ArgumentError: ref of NULL PyObject because the Python API was not loaded into Julia as in the following example:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Does not work: ❌","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using EarthEngine\n\ndem = EE.Image(\"USGS/SRTMGL1_003\")\n# ERROR: UndefVarError: Image not defined\n# Stacktrace:\n#     ...","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Works: ✅","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using EarthEngine\n# Intialize the API\nInitialize()\n\ndem = EE.Image(\"USGS/SRTMGL1_003\")\n# returns: EarthEngine.Image(PyObject <ee.image.Image object at ...>)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Once imported, the module exports the variable EE which allows for users to access the Earth Engine types in Julia with abbreviated syntax. For example, instead of writing img = EarthEngine.Image() users can write img = EE.Image(). Just for illustration, we can see that the two ways of calling the module are equal:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"EarthEngine.Image === EE.Image\n# returns: true","category":"page"},{"location":"usage/#EE-Types","page":"Usage","title":"EE Types","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"One nice feature of  Julia is that it supports types. This allows for easily creating user defined functions and code that are type safe.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The Julia types are are one-to-one mapping of the Earth Engine types such as Image, Feature, etc. One can access EE types using the following code: EE.Image (note the capitalized EE). These types are not to be confused with ee.Image which is the original Python object.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"typeof(ee.Image)\n# returns PyCall.PyObject\n\ntypeof(EE.Image)\n# returns DataType","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Consider the following example where we define a function that takes an EE.Image type as an input and returns an EE.Image type. This function will return an error if provided any other variable with a type that is not an EE.Image. Here is the following code:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# define a function that expects an EE.Image as input and returns EE.Image\nfunction ndvi(img::EE.Image)\n    return normalizedDifference(img, [\"B5\",\"B4\"])\nend\n\n# get an Image and calculate a FeatureCollection\nimg = EE.Image(\"LANDSAT/LC08/C01/T1_TOA/LC08_033032_20170719\")\nfc = sample(img;scale=30,numPixels=500)\n\n# works\nndvi(img)\n# returns: EarthEngine.Image(PyObject <ee.image.Image object at ...>)\n\n# does not work\nndvi(fc)\n#ERROR: MethodError: no method matching ndvi(::EarthEngine.FeatureCollection)\n#Closest candidates are:\n#  ndvi(::EarthEngine.Image) at REPL[XX]:1","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Again, this allows users to create type safe user defined functions. This also allows users to take advantage of Julia's amazing multiple dispatch feature.","category":"page"},{"location":"usage/#Leveraging-Julia's-multiple-dispatch","page":"Usage","title":"Leveraging Julia's multiple dispatch","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Julia's multiple dispatch is a powerful feature that allows users to define multiple functions with the same name but have different functionality depending on the type. Building off of our previous example of calculating NDVI, here we are going to define additional functions called ndvi that perform computations on different types within a workflow:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# define an ndvi function to calculate for EE.FeatureCollection\nfunction ndvi(fc::EE.FeatureCollection)\n    # map the ndvi-feature function over the fc\n    return map(fc,ndvi)\nend\n\n# define ndvi function to calculate from two Numbers\nfunction ndvi(nir::EE.Number,red::EE.Number)\n    # compute ndvi from numbers\n    return divide(subtract(nir,red),add(nir,red))\nend\n\n# define an ndvi function to calculate for EE.Feature\nfunction ndvi(f)\n    f = EE.Feature(f) # cast type here so we can use EE.map\n    r = EE.Number(get(f,\"B4\"))\n    n = EE.Number(get(f,\"B5\"))\n    # apply ndvi-number function\n    val = ndvi(n,r)\n    return set(f,\"ndvi\",val)\nend\n\n# input a FeatureCollection into ndvi\nndvi_fc = ndvi(fc)\n# returns: EarthEngine.FeatureCollection(PyObject <ee.featurecollection.FeatureCollection object at ...>)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"If you are used to Python then this code should not work (at least not return a FeatureCollection). We clearly defined ndvi multiple times and the last definition should not work with a FeatureCollection...so how does it work!? This is the power of multiple dispatch! By providing types Julia is able to determine which function to use depending on the input values.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"We can check the different signatures of the function ndvi with the following code:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# check the signatures of `ndvi`\nmethods(ndvi)\n# # 4 methods for generic function \"ndvi\":\n# [1] ndvi(img::EarthEngine.Image) in Main at REPL[XX]:2\n# [2] ndvi(fc::EarthEngine.FeatureCollection) in Main at REPL[XX]:2\n# [3] ndvi(nir::EarthEngine.Number, red::EarthEngine.Number) in Main at REPL[XX]:2\n# [4] ndvi(f) in Main at REPL[XX]:2","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"If you are interested in learning more about multiple dispatch, then please see the following presentation: The Unreasonable Effectiveness of Multiple Dispatch by Stefan Karpinski.","category":"page"},{"location":"usage/#Arithmetic-with-EE-Types","page":"Usage","title":"Arithmetic with EE Types","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Thanks to Julia's multiple dispatch, most mathematical operations on EE Types are supported and are dispatched to the correct method based on type. This makes the syntax for developing algorithms that use math more compact and look more like equations. A quick example of this can be seen when calculate EVI for an image and threshold to determine vegetated areas:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"img = EE.Image(\"LANDSAT/LT05/C01/T1_SR/LT05_034033_20000913\")\n\n# extract bands\nb = select(img,\"B1\")\nr = select(img,\"B3\")\nn = select(img,\"B4\")\n\n# apply evi equation\nevi = 2.5 * (n - r) / (n + (6 * r) - (7.5 * b) + 1)\n# returns: EarthEngine.Image(PyObject <ee.image.Image object at ...>)\n\n# get evi values over 0.5\nveg = evi > 0.5\n# returns: EarthEngine.Image(PyObject <ee.image.Image object at ...>)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"These kind of math operators work on all EE types and will dispatch to the equivalent EE operations if they are available for the types. All arithmetic operators,most bitwise operators, and all numeric comparisons are supported.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"It should be noted that if using mathematical operations with EE types, then the results will always be evaluated as Earth Engine server-side operations. Comparisons of values, such as img1 == img2 is equivalent to eq(img1,img2) (i.e. server-side operations) and should not be used for client-side comparisons.","category":"page"},{"location":"usage/#Quirks","page":"Usage","title":"Quirks","text":"","category":"section"},{"location":"usage/#Constructors-with-multiple-dispatch","page":"Usage","title":"Constructors with multiple dispatch","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Due to Julia's multiple dispatching based on type, sometimes you will have to provide a type as the first argument into a constructor method for an EE object. For example, the function gt() has multiple uses: you can compared Images, Arrays, Numbers, etc. but there is also an EE.Filter constructor that we can create with gt(). If you try to create a filter using the keyword arguments as inputs, such as gt(;name=\"B4\",value=0.05), you will get an error because Julia cannot figure out which method signature to use. To overcome this, one can simply provide a blank object of the desired type as in below:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"filter = gt(EE.Filter(); name=\"B4\", value=0.05)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Julia will determine which method signature to use based on which type is provided, i.e. toList(EE.Reducer()) will return a reducer rather than a list.","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"When in doubt, you can always provide the EE.Type as the first argument when creating a new object. In reality, it is probably best practice so that the code is explicit on what type is used and more readable by users. Say we want to create a constant image, the two following lines of code are both valid:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"one = constant(1)\none = constant(EE.Image(),1)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"The method constant() is only used to create an image within Earth Engine but in this example providing the type allows for the signature to be defined and it is easy for readers to understand what constant is doing, ultimately making code more maintainable.","category":"page"},{"location":"usage/#Types-within-functions-when-using-map()","page":"Usage","title":"Types within functions when using map()","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"When using the EE Julia API (and relying on multiple dispatch to figure the correct methods to use with data), some type casting is required to define the type of data within functions. This is particularly the case when using mapping functions over EE Collections because information gets passed to multiple sources (i.e. Julia function -> Python -> Earth Engine servers). So, somewhere between all of the translation one needs to be explicit on type information. Take a simple example where a user wants to define a function to calculate NDVI using individual bands:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# NDVI fucntion\nfunction ndvi(img)\n    r = select(img,\"B4\")\n    n = select(img,\"B5\")\n\n    return (n-r)/(n+r)\nend\n\n# get image collection\nic = limit(EE.ImageCollection(\"LANDSAT/LC08/C01/T1_SR\"),100, \"CLOUD_COVER\")\n\n# apply function over imagery\nmap(ic, ndvi)\n# ERROR: PyError ...\n# AttributeError(\"'Image' object has no attribute 'map'\")","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"While this is a perfectly valid code to calculate NDVI from the Earth Engine perspective, this throws an error because within the function using select() doesn't know when method signature to use so it will use the first method signature available (which probably isn't the correct one). This ambiguity happens when the function is called via map() on the Python side; the inputs are Python Objects and not typed. So, to overcome this ambiguity, we can provide types to the function arguments so that methods within the function know which signature to use. However, this is not enough because the expected type for functions used with map are PyObject. To pass the EE types to Python we will use a macro provided by EarthEngine.jl, @eefunc, to wrap the typed function which will work on the Python side. The @eefunc macro takes a function and the expected EE type to ensure the correct information is passed back and forth between Python and Julia:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# NDVI fucntion with image casted to EE.Image\nfunction ndvi_typed(img::EE.Image)\n    r = select(img,\"B4\")\n    n = select(img,\"B5\")\n\n    return (n-r)/(n+r)\nend\n\n# apply new NDVI function with type casting\n# use the @eefunc macro to wrap the type in a Python-friendly function\nmap(ic, @eefunc ndvi_typed EE.Image)\n# returns: EarthEngine.ImageCollection(PyObject <ee.imagefeaturecollection.ImageCollection object at ...>)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"While this is not required all the time for mapping functions over EE.ImageCollection or EE.FeatureCollection, it is generally good practice to use @eefunc to ensure the types are all correct.","category":"page"},{"location":"usage/#Using-map()-with-EE.List-types","page":"Usage","title":"Using map() with EE.List types","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"Within the Python API, the ee.List object uses a special approach to manage applying user defined functions using map(). The underlying code uses inspection to gather arbitrary arguments and keywords but this inspection only works on functions created in Python (i.e. doesn't work for Julia functions converted to Python). Take a simple example were we would like to square a list of numbers which results in an error:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# get a list of values\nl = sequence(1, 10)\n\n# define a function to square values\nfoo(x) = multiply(x, x)\n\nmap(l, foo)\n# ERROR: PyError ....\n# TypeError('unsupported callable')","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Again, this is perfectly valid code, but what this means is that the EE Python API cannot understand how to use the function from the Julia side and is throwing an error. The @eefunc macro is used to overcome this error is provided to extract out a Python callable object from functions defined in Julia. If no type is provided to @eefunc it will simply wrap the Julia function on the Python side with no types. Therefore, users will only need to add in minimal code to make the function applicable as in the following example:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"map(l, @eefunc foo)\n# returns: EarthEngine.List(PyObject <ee.ee_list.List object at object at ...>)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"However, in more complex functions that require typing, the mapped function will need to take EE.ComputedObject types (this is the default type for all ee.List.map functions). For example, if we would like to extract date information from an ImageCollection and format the dates to a string we would need to first cast the variable to EE.Date in the function then apply format() (this is because format() has a signature for both EE.Number and EE.Date). On the server side Earth Engine lists only take ComputedObjects as the input argument and then we have to cast to the preffered type within the function or else we will get an error. perform whichever operations we would like within the function:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# define function to convert ee date object to string\nfunction bar(d)\n   d = EE.Date(d)\n   return format(d,\"YYYY-MM-dd\")\nend\n\n# define the function which takes EE.ComputedObject\nfunction bar_typed(d::EE.ComputedObject)\n    d = EE.Date(d)\n    return format(d,\"YYYY-MM-dd\")\n end\n\n# get a list of EE Dates\nic = limit(EE.ImageCollection(\"LANDSAT/LC08/C01/T1_SR\"), 10)\ndates = aggregate_array(ic, \"system:time_start\")\n\n# apply basic function...will get an error\nmap(dates, @eefunc bar)\n# ERROR: (in a Julia function called from Python)\n# JULIA: KeyError: key \"format\" not found\n\n# apply function typed with EE.ComputedObject\nmap(dates, @eefunc bar EE.ComputedObject)\n# returns: EarthEngine.List(PyObject <ee.ee_list.List object at ...>)","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"In short, if using map() with EE.List types you will need to use @eefunc macro to wrap the function and the only support type as input into functions for EE.List is EE.ComputedObject. If this is all too much, one can simply avoid using Lists altogether and do all of the processing with EE.Colletion types (in fact it is recommended to avoid converting Earth Engine data to lists).","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"There are more likely than not more quirks in using the EE API this way, these are some that have been found so far. If there is a question or some unexpected behavior please file an issue on the GitHub repo","category":"page"},{"location":"usage/#Using-the-Python-API-through-Julia","page":"Usage","title":"Using the Python API through Julia","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"The EarthEngine.jl package also exposes the ee Python module so one can use the same code as one would when programming in Python. See the following example of valid Julia and Python code:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"# import the EE package and Initialize an ee session\n# this is the only non-Python\nusing EarthEngine\nInitialize()\n\n# now we can access the `ee` module like we would with Python\ndem = ee.Image(\"USGS/SRTMGL1_003\");\nxy = ee.Geometry.Point(86.9250, 27.9881);\nvalue = dem.sample(xy,scale=30).first().get(\"elevation\")\nprintln(value.getInfo())\n# 8729","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Accessing the EE API this way is an exact match to the Python API so one can simply copy-paste whatever Python code you have using the ee module and it will work with this Julia API.","category":"page"},{"location":"examples/trendy_lights/#Trendy-Lights","page":"Trendy Lights","title":"Trendy Lights","text":"","category":"section"},{"location":"examples/trendy_lights/","page":"Trendy Lights","title":"Trendy Lights","text":"This example highlights how the EE Julia API can be used to process time series of data and calculate a trend in time. Example from the Javascript Trendy Lights example.","category":"page"},{"location":"examples/trendy_lights/#Code","page":"Trendy Lights","title":"Code","text":"","category":"section"},{"location":"examples/trendy_lights/","page":"Trendy Lights","title":"Trendy Lights","text":"using EarthEngine\nInitialize()\n\n# Add a band containing image date as years since 1990.\nfunction createTimeBand(img)\n  img = EE.Image(img)\n  starttime = EE.Date(\"1990-01-01\")\n  year = difference(date(img), starttime, \"year\")\n  return float(addBands(year,img))\nend\n\n# get night light collection and add time band\ncollection = map(\n  select(\n    EE.ImageCollection(\"NOAA/DMSP-OLS/CALIBRATED_LIGHTS_V4\")\n    ,\"avg_vis\"\n  ), createTimeBand\n)\n\n# Fit a linear trend to the nighttime lights collection.\nfit = reduce(collection, linearFit())\n\n# define a region to view results\npt = Point(15, 45)\nregion = bounds(buffer(pt,25e5))\n\n# Display trend in red/blue, brightness in green.\ngetThumbURL(fit, Dict(\n  :min => 0,\n  :max => (0.18, 20, -0.18,),\n  :bands => [\"scale\", \"offset\", \"scale\"],\n  :dimensions => 1024,\n  :region => region,\n  :format => \"png\"\n))","category":"page"},{"location":"examples/trendy_lights/#Expected-Results","page":"Trendy Lights","title":"Expected Results","text":"","category":"section"},{"location":"examples/trendy_lights/","page":"Trendy Lights","title":"Trendy Lights","text":"(Image: example_trendylights)","category":"page"},{"location":"examples/sentinel1_composite/#Sentinel1-Composite","page":"Sentinel 1 Composite","title":"Sentinel1 Composite","text":"","category":"section"},{"location":"examples/sentinel1_composite/","page":"Sentinel 1 Composite","title":"Sentinel 1 Composite","text":"This example highlights how the EE Julia API can be used to process Sentinel 1 imagery and create a temporal mosiac. Example from the Javascript Sentinel1 Composite example.","category":"page"},{"location":"examples/sentinel1_composite/#Code","page":"Sentinel 1 Composite","title":"Code","text":"","category":"section"},{"location":"examples/sentinel1_composite/","page":"Sentinel 1 Composite","title":"Sentinel 1 Composite","text":"using EarthEngine\nInitialize()\n\n# define S1 image collection\ncollection = EE.ImageCollection(\"COPERNICUS/S1_GRD\")\n\n# define a filter to select specific data from collection\n# filter by instrument mode\n# filter by specific band\n# fitler by orbit property\ndatafilter = And(\n    eq(EE.Filter(), \"instrumentMode\", \"IW\"),\n    listContains(\"transmitterReceiverPolarisation\", \"VV\"),\n    eq(EE.Filter(), \"orbitProperties_pass\", \"DESCENDING\"),\n)\n\n# apply filters to image collection\nfiltered = select(filter(collection,datafilter),[\"VV\"])\n\n# calculate mean composites for three different date ranges\nr = mean(filterDate(filtered,\"2016-04-01\", \"2016-05-30\"))\ng = mean(filterDate(filtered,\"2016-06-01\", \"2016-08-31\"))\nb = mean(filterDate(filtered,\"2016-09-01\", \"2016-11-30\"))\n\n# combine the three images into one rgb composite\ncomposite = cat(EE.Image(),[r,g,b])\n\n# define a region to view results\ngeometry = Point(5.7788, 52.7005)\nregion = bounds(buffer(geometry,10000))\n\n# get a link to view results\ngetThumbURL(composite, Dict(\n    :min => -25,\n    :max => 0,\n    :region => region,\n    :dimensions => 1024,\n))","category":"page"},{"location":"examples/sentinel1_composite/#Expected-result","page":"Sentinel 1 Composite","title":"Expected result","text":"","category":"section"},{"location":"examples/sentinel1_composite/","page":"Sentinel 1 Composite","title":"Sentinel 1 Composite","text":"(Image: example_s1_composite)","category":"page"},{"location":"examples/classification/#Classification","page":"Classification","title":"Classification","text":"","category":"section"},{"location":"examples/classification/","page":"Classification","title":"Classification","text":"This example highlights how the EE Julia API can be used to sample data and classify an image. Example from the Supervised Classification guide.","category":"page"},{"location":"examples/classification/#Code","page":"Classification","title":"Code","text":"","category":"section"},{"location":"examples/classification/","page":"Classification","title":"Classification","text":"using EarthEngine\nInitialize()\n\n# Make a cloud-free Landsat 8 TOA composite (from raw imagery).\nl8 = filterDate(\n  EE.ImageCollection(\"LANDSAT/LC08/C01/T1\"),\n  \"2018-01-01\", \"2018-12-31\"\n)\nimage = simpleComposite(l8; asFloat=true)\n\n# Use these bands for prediction.\nbands = EE.List([\"B2\", \"B3\", \"B4\", \"B5\", \"B6\", \"B7\", \"B10\", \"B11\"])\n\n# Load training points. The numeric property 'class' stores known labels.\npoints = EE.FeatureCollection(\"GOOGLE/EE/DEMOS/demo_landcover_labels\")\n\n# This property stores the land cover labels as consecutive\n# integers starting from zero.\nlabel = \"landcover\"\n\n# Overlay the points on the imagery to get training data\ntraining = sampleRegions(\n  select(image, bands);\n  collection = points,\n  properties = [label],\n  scale = 30\n)\n\n# Train a CART classifier with default parameters.\nmodel = train(smileCart(), training, label, bands)\n\n# Classify the image\nclassified = classify(image, model)\n\n# define a region to view results\nregion = bounds(buffer(points, 5000))\n\n# Display the inputs and the results.\nimgthumb = getThumbURL(image, Dict(\n  :bands => \"B7,B5,B3\",\n  :min => 0.05,\n  :max => 0.55,\n  :gamma => 1.5,\n  :region => region,\n  :dimensions => 1024\n))\n\nclassificationthumb = getThumbURL(classified, Dict(\n  :min => 0,\n  :max => 2,\n  :palette => \"red, green, blue\",\n  :region => region,\n  :dimensions => 1024\n))","category":"page"},{"location":"examples/classification/#Expected-result","page":"Classification","title":"Expected result","text":"","category":"section"},{"location":"examples/classification/","page":"Classification","title":"Classification","text":"Landsat Image Classified Image\n(Image: ) (Image: )","category":"page"},{"location":"examples/landsat8_cloudmasking/#Landsat-8-Cloud-Masking","page":"Landsat 8 Cloud Masking","title":"Landsat 8 Cloud Masking","text":"","category":"section"},{"location":"examples/landsat8_cloudmasking/","page":"Landsat 8 Cloud Masking","title":"Landsat 8 Cloud Masking","text":"This example highlights how the EE Julia API can be used to create a function and apply over imagery. Example from the Javascript Landsat8 Surface Reflectance example.","category":"page"},{"location":"examples/landsat8_cloudmasking/#Code","page":"Landsat 8 Cloud Masking","title":"Code","text":"","category":"section"},{"location":"examples/landsat8_cloudmasking/","page":"Landsat 8 Cloud Masking","title":"Landsat 8 Cloud Masking","text":"using EarthEngine\nInitialize()\n\n# Function to cloud mask from the pixel_qa band of Landsat 8 SR data.\nfunction maskL8sr(image)\n    image = EE.Image(image) # cast to make sure we have the correct type\n\n    # Bits 3 and 5 are cloud shadow and cloud, respectively.\n    cloudShadowBitMask = 1 << 3\n    cloudsBitMask = 1 << 5\n\n    # Get the pixel QA band.\n    qa = select(image, \"pixel_qa\")\n\n    # Both flags should be set to zero, indicating clear conditions.\n    mask = And(\n        eq(bitwiseAnd(qa, cloudShadowBitMask), 0),\n        eq(bitwiseAnd(qa, cloudsBitMask), 0)\n    )\n\n    # Return the masked image, scaled to reflectance, without the QA bands.\n    return copyProperties(\n        select(\n            divide(\n                updateMask(\n                    image,\n                    mask\n                ),\n                10_000\n            ),\n            \"B[0-9]*\"\n        ),\n        image, [\"system:time_start\"]\n    )\nend\n\n# get the landsat collection and filter by date\ncollection = filterDate(\n    EE.ImageCollection(\"LANDSAT/LC08/C01/T1_SR\"),\n    \"2016-01-01\", \"2016-12-31\"\n)\n\n# apply the quality masking function\nmasked = map(collection, maskL8sr)\n\n# calculate median pixel\ncomposite = median(masked)\n\n# define a region to view results\nmntview = Point(-122.0839, 37.3861)\nregion = bounds(buffer(mntview, 5e4))\n\n# get a link to view results\ngetThumbURL(composite, Dict(\n    :bands => \"B7,B5,B3\",\n    :min => 0.05,\n    :max => 0.55,\n    :gamma => 1.5,\n    :region => region,\n    :dimensions => 1024\n))","category":"page"},{"location":"examples/landsat8_cloudmasking/#Expected-result","page":"Landsat 8 Cloud Masking","title":"Expected result","text":"","category":"section"},{"location":"examples/landsat8_cloudmasking/","page":"Landsat 8 Cloud Masking","title":"Landsat 8 Cloud Masking","text":"(Image: example_l8_cloud_masking)","category":"page"},{"location":"#EarthEngine.jl","page":"Home","title":"EarthEngine.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: sourcecode) (Image: license)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Google Earth Engine in Julia!","category":"page"},{"location":"","page":"Home","title":"Home","text":"EarthEngine.jl is used to interface with the amazing cloud-based geospatial processing platform, Google Earth Engine, using the Julia programming language as a wrapper around the EE Python API.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can use EarthEngine.jl in the following two ways.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Interface with the good ole' object-oriented Python API that everyone knows and loves through Julia (i.e. imagecollection.filterDate(...).mean())\nInterface with Earth Engine using Julia-like syntax that leverages types and multiple dispatch (i.e. (mean(filterDate(imagecollection,...))))","category":"page"},{"location":"","page":"Home","title":"Home","text":"See the Usage page of the documentation for more details on how to use.","category":"page"},{"location":"#Why-Julia-Earth-Engine?","page":"Home","title":"Why Julia + Earth Engine?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Earth Engine has become a vital geospatial tool for many Earth science researchers and organizations. The officially supported Earth Engine APIs are written in JavaScript and Python. The Python API provides great flexability and many useful packages for downstream analysis, but what about other scientific programming languages? Community-developed APIs, like rgee are allowing developers to interface with EE using their favorite languages. This package provides the Earth Engine API for users who love programming in Julia!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia is a modern programming language that has the feel of a scripting language with the performance of compiled languages (thanks to its JIT compilation). Julia is full of features e.g. types and multiple dispatch that make developing EE workflows more expressive.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use Earth Engine with Julia, we will use the existing Python API and call the functions through Julia. This is done through Julia’s PyCall package but we will need to install the EE API for use within the Julia environment. To do this, use the following instructions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ julia\njulia> ]\npkg> add PyCall Conda\njulia> using Conda\njulia> Conda.add(\"earthengine-api\", channel=\"conda-forge\");","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now we can install the EarthEngine package. EarthEngine.jl is available through the Julia package registry, therefore you can install using the following code:","category":"page"},{"location":"","page":"Home","title":"Home","text":"$ julia\njulia> ]\npkg> add EarthEngine\njulia> using EarthEngine\njulia> Initialize()","category":"page"},{"location":"","page":"Home","title":"Home","text":"If everything went well then you should have been able to import the EarthEngine package and initialize a session without any errors.","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To get started illustrating how to execute EE workflows using Julia, some of the examples using the Python API are replicated using the EE Julia API.","category":"page"},{"location":"#Test-the-API","page":"Home","title":"Test the API","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The first example is focused on importing the packing and performing a small geospatial process. Here the SRTM elevation data is imported and queried at the geospatial coordinates of Mount Everest to get the elevation value.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using EarthEngine\nInitialize()\ndem = EE.Image(\"USGS/SRTMGL1_003\")\nxy = Point(86.9250, 27.9881)\nvalue = get(first(sample(dem, xy, 30)), \"elevation\")\nprintln(getInfo(value))\n# should print: 8729","category":"page"},{"location":"#Plotting-data-from-EE","page":"Home","title":"Plotting data from EE","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As a more extensive example, we will sample data from a raster dataset. This is a common workflow for geospatial sciences whether looking at relationships between variables or sampling data for ML workflows. Here we load in a Landsat image, sample band values, and plot the relationship of the bands.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots\nusing EarthEngine\nInitialize()\nimg = EE.Image(\"LANDSAT/LT05/C01/T1_SR/LT05_034033_20000913\")\nband_names = EE.List([\"B3\", \"B4\"])\nsamples_fc = sample(divide(select(img, band_names), 10000); scale=30, numPixels=500)\nreducer = repeat(toList(EE.Reducer()), length(band_names))\nsample_cols =  reduceColumns(samples_fc, reducer, band_names)\nsample_data = getInfo(get(sample_cols, \"list\"))\n\n# plot the results\ntheme(:bright)\nscatter(sample_data[1,:], sample_data[2,:], markersize=4, alpha=0.6, xlabel=\"Red\", ylabel=\"NIR\", leg=false)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The results should look like the following figure:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: example_scatterplot)","category":"page"},{"location":"#Image-processing-and-visualization","page":"Home","title":"Image processing and visualization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This next example is a common workflow to calculate NDVI from a Landsat 5 image. For this example we define a function, apply it to the image, and pull the results for visualization.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots, Colors, FileIO\nusing EarthEngine\nInitialize()\n\nimg = EE.Image(\"LANDSAT/LT05/C01/T1_SR/LT05_034033_20000913\")\n\nfunction ndvi(img::EE.Image)\n    return normalizedDifference(img, [\"B4\", \"B3\"])\nend\n\nndvi_img = ndvi(img)\n\ncolor_map = map(x -> hex(x,:RRGGBB), cgrad(:Greens_9));\n\nthumburl = getThumbUrl(\n    ndvi_img,\n    Dict(\n        \"min\" => 0,\n        \"max\" => 0.8,\n        \"dimensions\" => 1024,\n        \"palette\" => color_map,\n        \"format\" => \"png\",\n    )\n)\nlocalpath = download(thumburl)\n\npng = FileIO.load(localpath);\n\nplot(png, ticks = nothing, border = :none)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The results should look like the following image:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: example_ndvi)","category":"page"},{"location":"#Warning","page":"Home","title":"🚨 Warning 🚨","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is in development and should not be used for production services! This package provides a proof of concept in using the EarthEngine API with type definitions, which Julia provides. There may be some unexpected behavior with the conversion of types from the EE Python API to Julia, see the Quirks section of the documentation to learn more.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are most likely function definitions that clobber with the Julia Base definitions so if you come across any issues, please log an issue on Github so that it can be resolved.","category":"page"},{"location":"#Acknowlegments","page":"Home","title":"Acknowlegments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is heavily influenced by many of the great resources developed by the Earth Engine community such as rgee and other packages in the Google Earth Engine Community Org\nA lot of code was reused from Pandas.jl which illustrates how to wrap Python objects in Julia.","category":"page"}]
}
